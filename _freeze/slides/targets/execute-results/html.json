{
  "hash": "b11dc94c8cbbba5a12ddcb0845394b47",
  "result": {
    "markdown": "---\ntitle: \"{targets}\"\nformat: \n  revealjs:\n    theme:\n      - ../www/custom.scss\n---\n\n\n## What is `{targets}`?\n\n::: {style=\"height: 0px;\"}\n\n::: {.cell}\n<style type=\"text/css\">\ndiv.callout-caution{border-left-color:#5e81ac !important}div.callout-caution.callout-style-default .callout-caption{background-color:#5e81ac !important}div.callout-caution.callout-style-default .callout-title{background-color:rgba(94,129,172,0.501961) !important}div.callout-note{border-left-color:#b48ead !important}div.callout-note.callout-style-default .callout-caption{background-color:#b48ead !important}div.callout-note.callout-style-default .callout-title{background-color:rgba(180,142,173,0.501961) !important}div.callout-important{border-left-color:#d08770 !important}div.callout-important.callout-style-default .callout-caption{background-color:#d08770 !important}div.callout-important.callout-style-default .callout-title{background-color:rgba(208,135,112,0.501961) !important}div.callout-warning{border-left-color:#ebcb8b !important}div.callout-warning.callout-style-default .callout-caption{background-color:#ebcb8b !important}div.callout-warning.callout-style-default .callout-title{background-color:rgba(235,203,139,0.501961) !important}div.callout-tip{border-left-color:#a3be8c !important}div.callout-tip.callout-style-default .callout-caption{background-color:#a3be8c !important}div.callout-tip.callout-style-default .callout-title{background-color:rgba(163,190,140,0.501961) !important}.callout-icon-container>p{color:#a1b6cf !important}div.callout-caution .callout-icon::before{background-image:url(\"data:image/svg+xml,%3Csvg xmlns='https://www.w3.org/2000/svg' width='16' height='16' fill='%2388c0d0' viewbox='0 0 16 16'%3E%3Cpath d='m8,0C3.58,0,0,3.58,0,8s3.58,8,8,8,8-3.58,8-8S12.42,0,8,0Zm0,1.02c3.85,0,6.98,3.12,6.98,6.98s-3.12,6.98-6.98,6.98S1.02,11.85,1.02,8,4.15,1.02,8,1.02Zm.12,1.7c-.44,0-.85.06-1.22.16-.38.11-.73.28-1.03.5-.26.19-.51.43-.7.68-.33.44-.52.93-.56,1.5,0,.04,0,.07,0,.07,0,0,1.74.22,1.74.22,0,0,0-.02.02-.08.16-.65.44-1.08.88-1.34.35-.21.78-.29,1.26-.24.22.02.42.08.59.16.22.1.41.27.56.46.12.17.2.37.22.58,0,.06,0,.2,0,.26-.02.15-.06.27-.12.4-.06.13-.12.2-.22.3-.16.17-.41.39-.86.75-.29.24-.48.41-.65.59-.4.41-.58.73-.68,1.18-.07.3-.1.6-.09,1.06,0,.11,0,.22,0,.24v.03h1.73v-.19c0-.26.02-.43.05-.59.05-.26.11-.4.32-.62.13-.14.3-.3.55-.52.38-.32.65-.56.9-.81.39-.39.6-.66.74-.98.11-.25.18-.49.2-.76,0-.07,0-.24,0-.32-.04-.56-.25-1.06-.65-1.52-.06-.07-.22-.23-.3-.3-.4-.35-.86-.59-1.4-.73-.34-.08-.66-.13-1.07-.14-.06,0-.13,0-.19,0h0Zm-.87,8.29v1.76h1.76v-1.76h-1.76Z'%3E%3C/path%3E%3C/svg%3E\") !important}div.callout-tip .callout-icon::before{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAp1JREFUWEftls1rE0EUwN9mu0ZR/IDsNilaQUQPiv4BglhpbRPRgpTeBvI32HTjMadKuqn4JyzMsXhQaddYURQ8eFT0IOLBz3SbVpQqNo2bSkZ32WxmZme3uQjmtGTex2/ee/PekyDKb6m4D8vqV54Kan4ehNEbH0TNSkKCd6dSeHemLiT7V0gUhA+wBRJ+VGnRHKNm/QzIidfkzGkdx4r6NCiXb6yMO9nZOzxwNgDFOXLqh2Gk/J4biaXiIJbVd34ZdL7A9MM8wA8rW6JGaECi+nSA+/oA7tM+uYZ5N+BFww+BNuyjkDPeBuWpAB2KnPCJFGWYrW6A6tVDWBkgeUatL2kYnrFFHDFlqgUNK2liA/2yj8EF441ftgsgjDgODM8mEyDfrOWc0TkrjsOgjlydyppKZpFEIZBSJgBy6vthpPytFwDg66Bo9VkfTM47rl02wDaLLwjupgG11lIwfH2NDuBrPnGfHitiHoD08QAM3fTmCTsCP2oqXJpb7UkKfLMEDRUSIIHX5NhFuGlPOGPGrV4AyJZ+xUxqxJZwEdKE48JEeobw4NoRnEiRlokay6chW3kR1zHRswqncDL9/E9j6yzA9n/hrfjJdxlKJepIDgUrlRL47B7vydEKmz6MfO1zO6noCP36yl4Yn10XGkZtIdmazpnJ/oX2d75hTzpZYz70xj4BuapPmIpGdNCGfQ5yxmOaPncj6rhBlF1vUT+Id2reXhhrISG0ga1ItDlFGWjhS+m94gm8Q31JQikyH/x9f7N+EsbKr3ipCwcAgCg3iiLLfIZd49TSL5tJ7XaUIhTZiIUBIPCeRUCQYP8QSkHbYXDLDYMQLdj/AP9OBKLUgWj+xV+BW3EL02m8q7/GK0D0087ARWM5rEjd89/mEzIwY1V62wAAAABJRU5ErkJggg==\") !important}div.callout-warning .callout-icon::before{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA4dJREFUWEfFVmtP01AYXmGbEJB1iEhwF4aIMYZoiKKBrWIiGIUyKGMJxpgYEow/gO985w+IGj+YeGM36DZNIFG2ghc03mJilOgYVQMBWYdiZB3MnINbumVd2xHkfOnJOe/leZ7z9j0HkW3zQLY5vyxrACFHGxbVmXyAgJz2N6oJN5xLHVkBCDlbD0e1J99wk8mDVK3aQr7ecgCxmAxZfDmwni5RydG+HASRxaSAkKxA2I53R/TYHZAkNzCFgu+aoY4BXyVNXVAR5O0tAzB3q7kg92DTL3juQapHbSFvgnnIab4U1RrhPBaY2llqtUEbMUOSAgsvBhLylnhXcpH+fngUsf7+nMWWgrV4wt3H+kTHFW0YHmqrihhM01Dq4MQJlWXkOZdh2NVeF9E0wDVl0FetsnigrdAQDYDLno+hGJtUQKIAhF342YgGewCc879TZYVmcj5sNx+P6I3PuIr8dHaU/tHWz8O1WapV1Ul6N61AbKhLuWioW009Xy5bsBdXJalOFh7lIeceJnzTgRFUICngq2klcvkaCwLxAYgN9ioWa/dHxBZkRgALI23lsnLTNxBMQVPNKEGOxQPzAQD7jMN8mtUZoS0S8GlKrB4YQ7ICmYoqE4BUhTL9lrwKLNvM9asVxknIPuCvRK3uAJeBEICQq70iqmmAPrm0z1RMeCZEKyCmsXBbsjLoP6+yuO+mJkiqn8CUHLHaEs0qbptWAcaB97I6bBAYsXP+gnLc/Ts1eMjW3hitaHgM1uUzk6fUXcPjqTb0UFd+nqEO+ipo6gpKkFcF+wDjaVGzexqX/jlZUYK0pZNu2dlRvaqt/wj2dtBPDhQRrk/p7Bg73snqMTvYUwamdqmsNhibVwGx3Yx7LQtdw5liJh3B0rC5Zm2v8d1G4YzXFBPe93y/j5T1H3b80Loeg7HktO+ImvC8TauAWPZSksdtkwqS83BJKMDYcSurx+7Ds58fL0ZbvaFMiRhnWxOrNY1C+xn/GbTLDed8I+RqR6OaBhhTSVPdKoK8B+YQAPehoQhSvaiFvC7EUqgPpC1IB97D6rAbYG/tw1hh2cXRFQiA76GRCUQ2ANL1F4RxtFSyusbPG7+Tr76I8DwVYg/2pR5BPCb3Gld8naxCtrLw+IhwcyYAKGbH96Gd3i9i2G/WhntPJCmw2cDZ+CPMEG5gDdh/YZ4KEKgu+CLKhpUUn20H8BfRiJwMGfDNGwAAAABJRU5ErkJggg==\") !important}div.callout-important .callout-icon::before{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAqtJREFUWEdjZCAS3A4NFf3z/7f2XavY/fi0KB9b7Mj6l/Gayvr1r4gxmpGQomtBQfL3bKIfEFKHTV7pyFIFrXXrHuLTi9MBj0NDOS9aRnzDpVn56CIP9t//L3xn/8PI9I9V/6513A5cavWPr+CSXb36OzZ5rA64Geyrcds64TqyBvVDi1VUN2y4S0xI3A4IUL5pF3sHWa3q0QWa6ms330DXj+GA28F+hjet48/BFCofX2KluXr9cWIsRldzPTTQ8q5lzDGYuPrRhUaqazedR1aH4oAbfn5Sdxzin8IUGO1fwC21eTPOaCDGUc98fbnOOSZ8halVObBQWmPTpmcwPtwB/0NDmbdaRvyBSUjc2MlmMmvWb2IsIaTmTFoa6wsN918wdd7HV7Awrl79F8SHO2BL39r/MAWqpxeIqi/f/IaQwaTI34z0FbltmvAapsenKBhsN5i44+8ve8M+7hGIrXZkkavauo17CBl+K9jf/JZ13AmwnqOLLNTWbjxJUE+Qv8stm7jdIHUaBxfJqWzc+BjsAGTfw1xGyDBkPSC15OgD6WG8HhgofNc2BhzcyoeXqGuuX3+LkOXojibFAdcDA9Xu2sbchNonwkiO7ylxALreweMA9aMLdFTXbr5KTPBTGgK3g321b1onXAHnAlgU4CuvsTmK3EQIMgu5noE7gNhUDHPM9ZAAB1jVDKqCNddsOEBs6CGHIPkOQE3NROcemCNhIUh2FPxnYGDc2rf2H8hA76JgJkYGBnhJSigksEYBqYmQkCX45LEmQlIKE0osp1o5cCvQz/WWbfwukIHqxxa7q67ZAGYTA5Bz0MAXxQNeGYEcQFZ1TEYU3MJVHaOHAt0bJCAHDHiTDOSIAW2UwrLPgDbLYY4Y0I4JzBED2jVDLs0GrHOKXqTSqnsOAJxF1JQ5aCVbAAAAAElFTkSuQmCC\") !important}div.callout-note .callout-icon::before{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAuxJREFUWEdjZCASeLY9F/39l0U7TX3/fnxaZt10dGT6+/fargaJV8QYzUhIkVPLe/kMtd0PCKnDJj/jlqvCvhrBh/j04nSAZd9jzkKZ499waZ513dnjP8ufC39/MzKyMDLrp2nu3YFLbf8TS67jRbLfscljdYBbwxuNFK1915E1zLhpr7KvVvwuMSHh1PxSOUP94B1ktXOuOWnuahC5ga4fwwEuTa8M0zQOnIMpnHnD2WpvnfBxYixGV+Pc9NYyXWPvMZj4rBsORnvqxM4jq0NxgGvDa6lUrf1PYQoWX7Ph3twghTMaiHGUb8MzrlitI19hamdfc5Te3SD6DMaHOyB01X/mUIbVf2ASne9D2c6mM/4mxhJCaoxn/mctF1z9C6ZuNUMoy+owxr8gPtwBq1at+g9TMO2ah+iBBr43+Ax2a3zrmqK5dxdIzZzrzm676oV341Pv0PBJJEtrx2uYmrCwMLDdYMKt5a1sitreRyD2zJtOrntrRfYQ8hWyg0FqYQbi0+fc/MYlXX0f2KFzbjnL7aoRfgx2ALJhxBiErodYB2Czi9G57ZNwusoOcHDPvOaovrdB9BYh34NDjcQogJnp3PBaLV1r/02wfXc8RBjJ8T0xDsSnBtnOweOAuTecdXbWCV8lxncuLW8t0tT2ohROxKYdkPnuTW+1kzX2XgHnAlhw4Cuv0R2FngNISYQgtcj1DNwBpPiAklwA8wzME1RxwLybjho7akXBKZtYgOEAUqIAIz+HhjIxMDLCS1JCjsAaBaQkQvQKhtTow5oISUlILi3vbNLU9hyG+ZRUB1BcDiAbMOe6o9+uetHNhIIdWR7FAeQUxcgGzLxtL7G3WvwlsQ7AKIrJqYwoKb7R9ZJVHZNbEOGsjtFDgVCDBN0B8685y25vEH6CLxrwNkhAGklqkv3/z+jU+kGOhf3nm12lEvD2Hi4HENUkA2ke0EYpzPUD2iyHOWJAOyYwRwxo1ww5MQ1Y5xQ9RdOqew4AmQrjruDNt+sAAAAASUVORK5CYII=\") !important}.reveal .smaller .callout.callout-titled .callout-icon::before{margin-top:0.5rem !important}\n</style>\n:::\n\n\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n![](https://github.com/ropensci/targets/blob/main/man/figures/logo.png?raw=true)\n:::\n\n::: {.column width=\"50%\"}\n\"a Make-like pipeline tool for statistics and data science in R\"\n\n-   manage a sequence of computational steps\n-   only update what needs updating\n-   ensure that the results at the end of the pipeline are still valid\n:::\n:::\n\n## Script-based workflow {.smaller}\n\n`01-data.R`\n\n``` r\nlibrary(tidyverse)\ndata <- read_csv(\"data.csv\", col_types = cols()) %>% \n    filter(!is.na(Ozone))\nwrite_rds(data, \"data.rds\")\n```\n\n`02-model.R`\n\n``` r\nlibrary(tidyverse)\ndata <- read_rds(\"data.rds\")\nmodel <- lm(Ozone ~ Temp, data) %>% \n    coefficients()\nwrite_rds(model, \"model.rds\")\n```\n\n`03-plot.R`\n\n``` r\nlibrary(tidyverse)\nmodel <- read_rds(\"model.rds\")\ndata <- read_rds(\"data.rds\")\nggplot(data) +\n    geom_point(aes(x = Temp, y = Ozone)) +\n    geom_abline(intercept = model[1], slope = model[2])\nggsave(\"plot.png\", plot)\n```\n\n::: aside\nBased on example in <https://books.ropensci.org/targets>\n:::\n\n## Problems with script-based workflow\n\n-   **Reproducibility**: if you change something in one script, you have to remember to re-run the scripts that depend on it\n-   **Efficiency**: that means you'll usually rerun all the scripts even if they don't depend on the change\n-   **Scalability**: if you have a lot of scripts, it's hard to keep track of which ones depend on which\n-   **File management**: you have to keep track of which files are inputs and which are outputs and where they're saved\n\n## \\# `{targets}`: The basics\n\n\n{{< video https://vimeo.com/700982360 width=\"100%\" height=\"100%\" >}}\n\n\n\n## `{targets}` workflow\n\n`R/functions.R`\n\n``` r\nget_data <- function(file) {\n  read_csv(file, col_types = cols()) %>%\n    filter(!is.na(Ozone))\n}\n\nfit_model <- function(data) {\n  lm(Ozone ~ Temp, data) %>%\n    coefficients()\n}\n\nplot_model <- function(model, data) {\n  ggplot(data) +\n    geom_point(aes(x = Temp, y = Ozone)) +\n    geom_abline(intercept = model[1], slope = model[2])\n}\n```\n\n## `{targets}` workflow\n\n`_targets.R`\n\n``` r\nlibrary(targets)\n\ntar_source()\ntar_option_set(packages = c(\"tidyverse\"))\n\nlist(\n  tar_target(file, \"data.csv\", format = \"file\"),\n  tar_target(data, get_data(file)),\n  tar_target(model, fit_model(data)),\n  tar_target(plot, plot_model(model, data))\n)\n```\n\nRun `tar_make()` to run pipeline\n\n::: callout-tip\n`use_targets()` will generate a `_targets.R` script for you to fill in.\n:::\n\n## `{targets}` workflow\n\nTargets are \"hidden\" away where you don't need to manage them\n\n```         \n├── _targets.R\n├── data.csv\n├── R/\n│   ├── functions.R\n├── _targets/\n│   ├── objects\n│          ├── data\n│          ├── model\n│          ├── plot\n```\n\n::: callout-tip\nYou can of course have multiple files in `R/`; `tar_source()` will source them all\n:::\n\n## My typical workflow with `{targets}`\n\n::: smaller\n1.  Read in some data and do some cleaning until it's in the form I want to work with.\n2.  Wrap that in a function and save the file in `R/`.\n3.  Run `use_targets()` and edit `_targets.R` accordingly, so that I list the data file as a target and `clean_data` as the output of the cleaning function.\n4.  Run `tar_make()`.\n5.  Run `tar_load(clean_data)` so that I can work on the next step of my workflow.\n6.  Add the next function and corresponding target when I've solidified that step.\n:::\n\n::: callout-tip\nI usually include `library(targets)` in my project `.Rprofile` so that I can always call `tar_load()` on the fly\n:::\n\n## `_targets.R` tips and tricks\n\n``` r\nlist(\n  tar_target(\n    data_file,\n    \"data/raw_data.csv\",\n    format = \"file\"\n  ),\n  tar_target(\n    raw_data,\n    read.csv(data_file)\n  ),\n  tar_target(\n    clean_data,\n    clean_data_function(raw_data)\n  )\n)\n```\n\n::: callout-tip\nI like to pair my functions/targets by name so that the workflow is clear to me\n:::\n\n## `_targets.R` tips and tricks\n\n``` r\npreparation <- list(\n  ...,\n  tar_target(\n    clean_data,\n    clean_data_function(raw_data)\n  )\n)\nmodeling <- list(\n  tar_target(\n    linear_model,\n    linear_model_function(clean_data)\n  ),\n  ...\n)\nlist(\n  preparation,\n  modeling\n)\n```\n\n::: smaller\n::: callout-tip\nBy grouping the targets into lists, I can easily comment out chunks of the pipeline to not run the whole thing\n:::\n:::\n\n## `_targets.R` tips and tricks\n\n::: columns\n::: {.column width=\"65.5%\"}\n``` r\n## prepare ----\nprepare <- list(\n  ### cleanData.csv ----\n  tar_target(\n    cleanData.csv,\n    file.path(path_to_data, \n              \"cleanData.csv\"),\n    format = \"file\"\n  ),\n  ### newdat ----\n  tar_target(\n    newdat,\n    read_csv(cleanData.csv, \n             guess_max = 20000)\n  ),\n  ...\n```\n:::\n\n::: {.column width=\"34.5%\"}\n![](../img/outline.png)\n:::\n:::\n\n::: callout-tip\nIn big projects, I comment my `_targets.R` file so that I can use the RStudio outline pane to navigate the pipeline ([my buggy function](https://github.com/louisahsmith/louisahstuff/blob/master/R/outline_targets.R))\n:::\n\n## Key `{targets}` functions {.smaller}\n\n-   `use_targets()` gets you started with a `_targets.R` script to fill in\n-   `tar_make()` runs the pipeline and saves the results in `_targets/objects/`\n-   `tar_make_future()` runs the pipeline in parallel[^1]\n-   `tar_load()` loads the results of a target into the global environment\\\n    (e.g., `tar_load(clean_data)`)\n-   `tar_read()` reads the results of a target into the global environment\\\n    (e.g., `dat <- tar_read(clean_data)`)\n-   `tar_visnetwork()` creates a network diagram of the pipeline\n-   `tar_outdated()` checks which targets need to be updated\n-   `tar_prune()` deletes targets that are no longer in `_targets.R`\n-   `tar_destroy()` deletes the `.targets/` directory if you need to burn everything down and start again\n\n[^1]: Note: `{targets}` is moving to a new distributed computing strategy using `{crew}`\n\n# Advanced `{targets}`\n\n## \"target factories\"\n\n![](../img/factories.png){.r-stretch}\n\n## `{tarchetypes}`: reports\n\nRender documents that depend on targets loaded with `tar_load()` or `tar_read()`.\n\n-   `tar_render()` renders an R Markdown document\n-   `tar_quarto()` renders a Quarto document (or project)\n\n::: callout-warning\nIt can't detect dependencies like `tar_load(ends_with(\"plot\"))`\n:::\n\n## What does `report.qmd` look like?\n\n````         \n---\ntitle: \"My report\"\n---\n```{{r}}\nlibrary(targets)\ntar_load(results)\ntar_load(plots)\n```\nThere were `r results$n` observations with a mean age of `r results$mean_age`.\n```{{r}}\nlibrary(ggplot2)\nplots$age_plot\n```\n````\n\nBecause `report.qmd` depends on `results` and `plots`, it will only be re-rendered if either of those targets change.\n\n::: callout-tip\nThe `extra_files =` argument can be used to force it to depend on additional non-target files\n:::\n\n## `{tarchetypes}`: branching {.smaller}\n\nUsing data from the National Longitudinal Survey of Youth,\n\n::: columns\n::: {.column width=\"39%\"}\n`_targets.R`\n\n``` r\nlibrary(targets)\nlibrary(tarchetypes)\ntar_source()\n\ntargets_setup <- list(\n  tar_target(\n    csv,\n    \"data/nlsy.csv\",\n    format = \"file\"\n  ),\n  tar_target(\n    dat,\n    readr::read_csv(csv, \n      show_col_types = FALSE)\n  )\n)\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"59%\"}\n`R/functions.R`\n\n``` r\nmodel_function <- function(outcome_var, \n                           sex_val, dat) {\n\n  lm(as.formula(paste(outcome_var, \n      \" ~ age_bir + income + factor(region)\")) ,\n     data = dat, \n     subset = sex == sex_val)\n}\n\ncoef_function <- function(model) {\n  coef(model)[[\"age_bir\"]]\n}\n```\n:::\n:::\n\nwe want to investigate the relationship between age at first birth and hours of sleep on weekdays and weekends among moms and dads separately\n\n## Option 1\n\nCreate (and name) a separate target for each combination of sleep variable (`\"sleep_wkdy\"`, `\"sleep_wknd\"`) and sex (male: `1`, female: `2`):\n\n``` r\ntargets_1 <- list(\n  tar_target(\n    model_1,\n    model_function(outcome_var = \"sleep_wkdy\", sex_val = 1, dat = dat)\n  ),\n  tar_target(\n    coef_1,\n    coef_function(model_1)\n  )\n)\n```\n\n... and so on...\n\n``` r\ntar_read(coef_1)\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.00734859\n```\n\n\n:::\n:::\n\n\n## Option 2\n\nUse `tarchetypes::tar_map()` to map over the combinations for you (static branching):\n\n``` r\ntargets_2 <- tar_map(\n  values = tidyr::crossing(\n    outcome = c(\"sleep_wkdy\", \"sleep_wknd\"),\n    sex = 1:2\n  ),\n  tar_target(\n    model_2,\n    model_function(outcome_var = outcome, sex_val = sex, dat = dat)\n  ),\n  tar_target(\n    coef_2,\n    coef_function(model_2)\n  )\n)\ntar_load(starts_with(\"coef_2\"))\nc(coef_2_sleep_wkdy_1, coef_2_sleep_wkdy_2, coef_2_sleep_wknd_1, coef_2_sleep_wknd_2)\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.00734859 0.01901772 0.02595109 0.01422970\n```\n\n\n:::\n:::\n\n\n## Option 2, cont.\n\nUse `tarchetypes::tar_combine()` to combine the results of a call to `tar_map()`:\n\n``` r\ncombined <- tar_combine(\n  combined_coefs_2,\n  targets_2[[\"coef_2\"]],\n  command = vctrs::vec_c(!!!.x),\n)\ntar_read(combined_coefs_2)\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\ncoef_2_sleep_wkdy_1 coef_2_sleep_wkdy_2 coef_2_sleep_wknd_1 coef_2_sleep_wknd_2 \n         0.00734859          0.01901772          0.02595109          0.01422970 \n```\n\n\n:::\n:::\n\n\n`command = vctrs::vec_c(!!!.x)` is the default, but you can supply your own function to combine the results\n\n## Option 3\n\n::: smaller\nUse the `pattern =` argument of `tar_target()` (dynamic branching):\n:::\n\n``` r\ntargets_3 <- list(\n  tar_target(\n    outcome_target,\n    c(\"sleep_wkdy\", \"sleep_wknd\")\n  ),\n  tar_target(\n    sex_target,\n    1:2\n  ),\n  tar_target(\n    model_3,\n    model_function(outcome_var = outcome_target, sex_val = sex_target, dat = dat),\n    pattern = cross(outcome_target, sex_target)\n  ),\n  tar_target(\n    coef_3,\n    coef_function(model_3),\n    pattern = map(model_3)\n  )\n)\ntar_read(coef_3)\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\ncoef_3_85bbb1b6 coef_3_c47db1e2 coef_3_5ba8b6ec coef_3_19c76a86 \n     0.00734859      0.01901772      0.02595109      0.01422970 \n```\n\n\n:::\n:::\n\n\n## Branching\n\n| **Dynamic**                              | **Static**                                         |\n|--------------------------------|----------------------------------------|\n| Pipeline creates new targets at runtime. | All targets defined in advance.                    |\n| Cryptic target names.                    | Friendly target names.                             |\n| Scales to hundreds of branches.          | Does not scale as easily for tar_visnetwork() etc. |\n| No metaprogramming required.             | Familiarity with metaprogramming is helpful.       |\n\n::: aside\nFrom <https://books.ropensci.org/targets/dynamic.html#branching>\n:::\n\n## Branching\n\n-   The book also has an example of using metaprogramming to map over different functions\n    -   i.e. fit multiple models with the same arguments\n-   Static and dynamic branching can be combined\n    -   e.g. `tar_map(values = ..., tar_target(..., pattern = map(...)))`\n-   Branching can lead to slowdowns in the pipeline (see book for suggestions)\n\n## `{tarchetypes}`: repetition\n\n`tar_rep()` repeats a target multiple times with the same arguments\n\n``` r\ntargets_4 <- list(\n  tar_rep(\n    bootstrap_coefs,\n    dat |>\n      dplyr::slice_sample(prop = 1, replace = TRUE) |>\n      model_function(outcome_var = \"sleep_wkdy\", sex_val = 1, dat = _) |>\n      coef_function(),\n    batches = 10,\n    reps = 10\n  )\n)\n```\n\nThe pipeline gets split into `batches` x `reps` chunks, each with its own random seed\n\n## `{tarchetypes}`: mapping over iterations\n\n``` r\nsensitivity_scenarios <- tibble::tibble(\n  error = c(\"small\", \"medium\", \"large\"),\n  mean = c(1, 2, 3),\n  sd = c(0.5, 0.75, 1)\n)\n```\n\n`tar_map_rep()` repeats a target multiple times with different arguments\n\n``` r\ntargets_5 <- tar_map_rep(\n  sensitivity_analysis,\n  dat |> \n    dplyr::mutate(sleep_wkdy = sleep_wkdy + rnorm(nrow(dat), mean, sd)) |>\n    model_function(outcome_var = \"sleep_wkdy\", sex_val = 1, dat = _) |>\n    coef_function() |> \n    data.frame(coef = _),\n  values = sensitivity_scenarios,\n  batches = 10,\n  reps = 10\n)\n```\n\n## `{tarchetypes}`: mapping over iterations\n\n``` r\ntar_read(sensitivity_analysis) |> head()\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n           coef error mean  sd tar_batch tar_rep    tar_seed tar_group\n1  0.0061384611 small    1 0.5         1       1 -1018279263         2\n2 -0.0005346553 small    1 0.5         1       2  -720048594         2\n3  0.0073674844 small    1 0.5         1       3 -1478913096         2\n4  0.0039254289 small    1 0.5         1       4 -1181272269         2\n5  0.0108489430 small    1 0.5         1       5   135877686         2\n6  0.0029473286 small    1 0.5         1       6  -564559689         2\n```\n\n\n:::\n:::\n\n\nIdeal for sensitivity analyses that require multiple iterations of the same pipeline with different parameters\n\n``` r\ntar_read(sensitivity_analysis) |>\n  dplyr::group_by(error) |> \n  dplyr::summarize(q25 = quantile(coef, .25),\n                   median = median(coef),\n                   q75 = quantile(coef, .75))\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   error         q25      median         q75\n1  large 0.001427986 0.007318120 0.011399772\n2 medium 0.004158480 0.007770285 0.011367160\n3  small 0.004058926 0.006614599 0.009004322\n```\n\n\n:::\n:::\n\n\n## Conclusion\n\n-   `{targets}` is a great tool for managing complex workflows\n-   `{tarchetypes}` makes it even more powerful\n-   The [user manual](https://books.ropensci.org/targets/) is a great resource for learning more\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}